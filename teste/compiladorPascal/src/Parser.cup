
import java_cup.runtime.*;
import java.util.*;
import java.io.*;


action code{:
  private HashMap<String, Symbol> table = new HashMap<String, Symbol>();
:};

parser code {:

    public void report_error(String message, Object info)  {
        System.out.println("Warning - " + message);
    }

    public void report_fatal_error(String message, Object info)  {
        System.out.println("Error - " + message);
        System.exit(-1);
    }

:};

action code {:

	class Exp {
	  public Tipo tipo;
	  public String code;
	  public boolean isConstant;

	  Exp(Tipo t, String code) {
		this(t, code, false);
	  }

	  Exp(Tipo t, String code, boolean cte) {
		tipo = t;
		this.code = code;
		isConstant = cte;
	  }

	}

	class Reg {


		public String id;
		public String val;

		Reg(String id) {
			this(id,"");
		}

		Reg(String id, String val) {
			this.id = id;
			this.val = val;
		}

	}

	public static String assembOp(String pascOper) {
		if(pascOper.equals("-")) {
			return "SUB";
		}
		else if(pascOper.equals("+")) {
			return "ADD";
		}
		else if(pascOper.equals("*")) {
			return "MUL";
		}
		else if(pascOper.equals("/") || pascOper.toLowerCase().equals("div")) {
			return "DIV";
		}
		return "";
	}

	/* listas auxiliares para gerenciar registradores */
	List<Reg> argRegs = new ArrayList<Reg> ();

	/* pesquisa um registrador argumento dado seu valor */
	public Reg getArgReg(String val) {
		for(Reg reg : argRegs) {
			if(reg.val.equals(val))
				return reg;
		}
		return null;
	}

	/* lista para gerenciar destino de la√ßos (labels) */
	List<Integer> labels = new ArrayList<Integer>();

	/* variavel auxiliar para manipulacao de labels */
	int label = 0;

:};

init with {:
	TabelaDeSimbolos.inicializa();
	Tipo.criaTipos();
:};

terminal IF, THEN, ELSE, DO, WHILE, UNTIL, READ, WRITE, FALSE, TRUE;
terminal PROGRAM, INTEGER, REAL, BOOLEAN, CHAR, BEGIN, END, LEFT, RIGHT;
terminal ADDOP, RELOP, ASSIGN, MULOP, SEMI, COLON, COMMA, MINUS;
terminal IDENTIFIER, INTEGER_CONSTANT, REAL_CONSTANT, CHAR_CONSTANT ;

non terminal  program, decl_list, decl, ident_list, compound_stmt, stmt_list;
non terminal  stmt, assign_stmt, if_stmt, cond, loop_stmt, stmt_prefix, stmt_suffix;
non terminal  read_stmt, write_stmt, expr_list, expr, simple_expr, term, factor_a;
non terminal  factor, constant, boolean_constant, type;

precedence left ELSE;

start with program;


program ::= PROGRAM IDENTIFIER SEMI decl_list compound_stmt {:
  parser.code.append("\t HALT \n\n");
:};

decl_list ::= decl_list  SEMI decl | decl ;

decl ::= ident_list:il  COLON type:tp {:
  for(String id : il){:
    if(! TabelaDeSimbolos.inserirVariavel(id.toLowerCase(), new Simbolo(id, tp))){
      parser.sem_error(id, "variavel ja existe");
    }
  }
:};

ident_list ::= ident_list:il  COMMA IDENTIFIER:id{:
  il.add(id.toLowerCase());
  RESULT = il;
:} | IDENTIFIER{:
  List<String> il = new ArrayList<String>();
  RESULT = il;
:} ;

type ::= INTEGER | REAL | BOOLEAN | CHAR ;

compound_stmt ::= BEGIN stmt_list END ;

stmt_list ::= stmt_list SEMI stmt | stmt ;

stmt ::= assign_stmt | if_stmt | loop_stmt | read_stmt | write_stmt | compound_stmt ;

assign_stmt ::= IDENTIFIER:identifier ASSIGN:assign expr:expr{:
  if(! tva.tipo.getVal().equals(texp.tipo.getVal())) {
   	if(! texp.tipo.getVal().equals("error") && ! tva.tipo.getVal().equals("error")) {
   		if(! (tva.tipo.getVal().equals("real") && texp.tipo.getVal().equals("integer"))) {
   				parser.sem_error(tva.tipo.getVal(), "cannot convert from "+ texp.tipo.getVal() + " to ");
   				RESULT = Tipo.getTipo(Tipo.ERRO);
   		}
   		else {
				parser.code.append("\t ST "+tva.code+" , "+texp.code +"\n");
        RESULT = Tipo.getTipo(Tipo.TIPO_VOID);
			}
		}
   }
   else {
    parser.code.append("\t ST "+tva.code+" , "+texp.code +"\n");
    RESULT = Tipo.getTipo(Tipo.TIPO_VOID);
   }
:} ;

if_stmt ::= IF cond THEN stmt  | IF cond THEN stmt ELSE stmt ;

cond ::= expr:exp {:
  if(exp != null) {
		if(! exp.tipo.getVal().equals("boolean")) {
			if(! exp.tipo.getVal().equals("error"))
				parser.sem_error(exp.tipo.getVal(), "cannot convert to boolean ");
	 		RESULT = new Exp(Tipo.getTipo(Tipo.ERRO), "");
		}
		else {
			RESULT = new Exp(exp.tipo, exp.code);
		}
	}
  :};

loop_stmt ::= stmt_prefix:wd DO stmt_list stmt_suffix
            {:
               parser.code.append("\t BR "+wd.get(0)+"\n");
               parser.code.append(wd.get(1)+":\n");
            :};

stmt_prefix ::= WHILE cond:be
            {:
							String lbl1 = "", lblFalse = "";

							labels.add(labels.size()+1);
							lbl1 = "$L"+labels.size();

							parser.code.append(lbl1+":\n");
							parser.code.append("\t LD R0 , "+be.code+"\n");
							parser.code.append("\t SUB R0 , R0 , 1\n");

							labels.add(labels.size()+1);
							lblFalse = "$L"+labels.size();

							parser.code.append("\t BLTZ R0 , "+lblFalse+"\n");

							List<String> whileArgs = new ArrayList <String> ();
							whileArgs.add(lbl1);
							whileArgs.add(lblFalse);

							RESULT = whileArgs;
						:}|  ;

stmt_suffix ::= UNTIL cond
            {:
              String lbl1 = "", lblFalse = "";

              labels.add(labels.size()+1);
              lbl1 = "$L"+labels.size();

              parser.code.append(lbl1+":\n");
              parser.code.append("\t LD R0 , "+be.code+"\n");
              parser.code.append("\t SUB R0 , R0 , 1\n");

              labels.add(labels.size()+1);
              lblFalse = "$L"+labels.size();

              parser.code.append("\t BLTZ R0 , "+lblFalse+"\n");

              List<String> whileArgs = new ArrayList <String> ();
              whileArgs.add(lbl1);
              whileArgs.add(lblFalse);

              RESULT = whileArgs;
            :} | END ;

read_stmt ::= READ LEFT ident_list RIGHT ;

write_stmt ::= WRITE LEFT expr_list RIGHT ;

expr_list ::= expr | expr_list COMMA expr ;

expr ::= simple_expr:se {: RESULT = new Exp(se.tipo, se.code); :} |
         simple_expr RELOP simple_expr
         {: RESULT = new Exp(Tipo.getTipo(Tipo.BOOLEAN), ""); :}
         ;

simple_expr ::= term:te {:
									RESULT = new Exp(te.tipo, te.code, te.isConstant);
						:} |
            simple_expr:se ADDOP:ad term:te
            {:
   						if(ad != null) {
   							if(ad.toLowerCase().equals("or")) {
   								if(!(se.tipo.getVal().equals("boolean") && te.tipo.getVal().equals("boolean"))) {
   									parser.sem_error(se.tipo.getVal() + ", " + te.tipo.getVal(), "The operator OR is undefined for the argument types ");
   									RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
   								}
   								else {
									if(! "R1".equals(se.code))
										parser.code.append("\t LD R1 , "+se.code+"\n");
									se.code = "R1";
									parser.code.append("\t OR "+se.code+" , "+se.code+" , "+te.code+"\n");
   									RESULT = new Exp(Tipo.getTipo(Tipo.BOOLEAN), se.code);
   								}
   							}
   							else if(ad.toLowerCase().equals("-") || ad.toLowerCase().equals("+")) {
   								if((se.tipo.getVal().equals("integer") || se.tipo.getVal().equals("real")) &&
   								  (te.tipo.getVal().equals("integer") || te.tipo.getVal().equals("real"))) {

									String op = assembOp(ad.toLowerCase());
									if(se.isConstant) {
										parser.code.append("\t "+op+" R1 , "+se.code+" , "+te.code+"\n");
										se.code = "R1";
									}
									else {
										parser.code.append("\t "+op+" "+se.code+" , "+se.code+" , "+te.code+"\n");
									}
   									RESULT = new Exp(Tipo.maximo(se.tipo, te.tipo), se.code);
   								}
   								else if((se.tipo.getVal().equals("char") || se.tipo.getVal().equals("string")) &&
   								  (te.tipo.getVal().equals("char") || te.tipo.getVal().equals("string"))) {
   									RESULT = new Exp(Tipo.maximo(se.tipo, te.tipo), "?");
   								}
   								else {
   									parser.sem_error(se.tipo.getVal() + ", " + te.tipo.getVal(), "The operator "+ad+" is undefined for the argument types ");
   									RESULT = new Exp(Tipo.getTipo(Tipo.ERRO), "");
   								}
   							}

   						}
   					:};

term ::= factor_a:f{: RESULT = new Exp(f.tipo, f.code, f.isConstant); |
         term:se MULOP:ad factor_a:te
         {:
   						if(ad != null) {
   							if(ad.toLowerCase().equals("and")) {
   								if(!(se.tipo.getVal().equals("boolean") && te.tipo.getVal().equals("boolean"))) {
   									parser.sem_error(se.tipo.getVal() + ", " + te.tipo.getVal(), "The operator AND is undefined for the argument types ");
   									RESULT = new Exp(Tipo.getTipo(Tipo.ERRO), "");
   								}
   								else {
									if(! "R1".equals(se.code))
										parser.code.append("\t LD R1 , "+se.code+"\n");
									se.code = "R1";
									parser.code.append("\t AND "+se.code+" , "+se.code+" , "+te.code+"\n");
   									RESULT = new Exp(Tipo.getTipo(Tipo.BOOLEAN), se.code);
   								}
   							}
   							else if(ad.toLowerCase().equals("*") || ad.toLowerCase().equals("/")) {
   								if((se.tipo.getVal().equals("integer") || se.tipo.getVal().equals("real")) &&
   								  (te.tipo.getVal().equals("integer") || te.tipo.getVal().equals("real"))) {
   									String op = assembOp(ad.toLowerCase());
									if(se.isConstant) {
										parser.code.append("\t "+op+" R1 , "+se.code+" , "+te.code+"\n");
										se.code = "R1";
									}
									else {
										parser.code.append("\t "+op+" "+se.code+" , "+se.code+" , "+te.code+"\n");
									}
   									RESULT = new Exp(Tipo.maximo(se.tipo, te.tipo), se.code);
   								}
   								else {
   									parser.sem_error(se.tipo.getVal() + ", " + te.tipo.getVal(), "The operator "+ad+" is undefined for the argument types ");
   									RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
   								}
   							}
   							else if(ad.toLowerCase().equals("mod") || ad.toLowerCase().equals("div")) {
   								if(se.tipo.getVal().equals("integer") && te.tipo.getVal().equals("integer")) {
									String op = assembOp(ad.toLowerCase());
									if(se.isConstant) {
										parser.code.append("\t "+op+" R1 , "+se.code+" , "+te.code+"\n");
										se.code = "R1";
									}
									else {
										parser.code.append("\t "+op+" "+se.code+" , "+se.code+" , "+te.code+"\n");
									}
   									RESULT = new Exp(Tipo.getTipo(Tipo.INTEGER), se.code);
   								}
   								else {
   									parser.sem_error(se.tipo.getVal() + ", " + te.tipo.getVal(), "The operator "+ad+" is undefined for the argument types ");
   									RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
   								}
   							}
   						}
   					:};

factor_a ::= MINUS:sn factor:f
        {:if(sn.toLowerCase().equals("-")) {
   					if(! (f.tipo.getVal().equals("integer") || f.tipo.getVal().equals("real"))) {
   						parser.sem_error(f.tipo.getVal(), "The operator - is undefined for the expression type");
   						RESULT = new Exp(Tipo.getTipo(Tipo.ERRO), "");
   					}
   					else {
   						RESULT = f;
   					}
   				}
        :}| factor:f {:
          if(! (f.tipo.getVal().equals("integer") || f.tipo.getVal().equals("real")
   					|| f.tipo.getVal().equals("string") || f.tipo.getVal().equals("char"))) {
   						parser.sem_error(f.tipo.getVal(), "The operator + is undefined for the expression type");
   						RESULT = new Exp(Tipo.getTipo(Tipo.ERRO), "");
   					}
   					else {
   						RESULT = f;
   					}
          :};

factor ::= IDENTIFIER | constant | LEFT expr RIGHT | RELOP factor ;

constant ::= INTEGER_CONSTANT | REAL_CONSTANT | CHAR_CONSTANT | boolean_constant ;

boolean_constant ::= FALSE | TRUE ;
